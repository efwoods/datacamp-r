
```{R}
print("Hello World")
```
```{R}
# Helpful Keybord Shortcuts:
print(" <- :alt+- ")
print(" %>% : ctrl + shift + m")
print(" code chunk == ctrl + shift + i ")
```

```{r}
# Datatypes
w <- 9 # Numeric
x <- 10.5 # Numeric
y <- 10L # Integer
z <- 1i # Complex
```


```{r}
# Type Conversion
# as.integer()
a <- as.numeric(y)
print(a)

# as.integer()
b <- as.integer(w)
class(b)

# as.complex()
c <- as.complex(w)
c
class(c)
```

```{r}
# Functions
abs(-4.7)
max(1, 4, 24)
min(4, 2, 5)
ceiling(1.4)
floor(1.4)
```

```{r}
# Strings
"hello"
"hello"
string <- "Hello World"
# multiline string is a single line. \n is only added at line breaks
multiline_string <- "Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."
cat(multiline_string) # addes linebreaks in the same position as the code
nchar(string) # string length
grepl("H", string) # Check a string for a sequence of characters in a string
grepl("h", string)
grepl("Hello", string)
grepl("X", string)

paste(string, multiline_string) # combine two strings
```

```{r}
# Escape characters
# \\ backslash
# \n New line
# \r Carriage Return
# \t Tab
# \b Backspace
```

```{r}
# assignment operators
my_var <- 3
my_var
my_new_var <<- 4 # This is a global assigner
my_new_var
1 -> my_var
my_var
5 ->> my_new_var # This is a global assigner
my_new_var

# %in%; finds out if an element belongs to a vector
y <- c(1, 2, 3, 4)
x <- 0
z <- 1

x %in% y
z %in% y

# : is used to create a series in a sequence
collection <- c(1:10)
print(collection)

x %in% collection
z %in% collection
y %in% collection



# %*% defines Matrix Multiplication
```

```{r}
# Function within a function
Outer_func <- function(x) {
    Inner_func <- function(y) {
        a <- x + y
        return(a)
    }
    return(Inner_func)
}
output <- Outer_func(3)
# output will save the value of the Outer_function for reuse
print(output)
output(5)
output(10)
```

```{r}
# Recursion
tri_recursion <- function(k) {
    if (k > 0) {
        print(paste("The value of k is: ", k))
        try(
            if (exists(result)) {
                print(paste("result exists:", result))
            }
        )
        result <- k + tri_recursion(k - 1) # k is stored each time;
        # then the tri_recursion method is called until k == 0
        # then the tri_recursion loops up using the stored values of k to complete the function from previous iterations
        print(paste("The value of result is:", result))
        print(paste("The value of k is: ", k))
        print(result)
    } else {
        print(paste("result is 0; k is: ", k))
        result <- 0
        return(result)
    }
}
tri_recursion(5)
```

```{r}
# Example of global assignment within a function
txt <- "awesome"
my_function <- function() {
    txt <<- "fantastic"
    paste("R is", txt)
}

my_function()

paste("R is", txt) # function will print "R is fantastic" because global assignment was used!
```

```{r}
# Vectors
fruits <- c("banana", "apple", "orange", "mango", "lemon")
numbers <- c(13, 3, 5, 7, 20, 2)

sort(fruits)
sort(numbers)

fruits[1]
fruits
fruits[c(1, 3)]
fruits[c(1:3)]

# Negative indices select all but the ones specified
fruits
fruits[c(-1)]
fruits[c(-2)]

fruits
fruits[c(-1:-3)]

fruits
fruits[c(-1, -4, -3)]

# repeat vectors
repeat_independent <- rep(c(1, 2, 3), times = c(5, 2, 1))
repeat_independent # this will repeat "1" five times, "2" two times, & "3" one time

# generating sequence vectors
sequence_of_numbers <- seq(from = 0, to = 100, by = 20)
sequence_of_numbers
```

```{r}
# Lists
thislist <- list(fruits) # this is a list containing a collection
thislist
class(thislist)

anotherlist <- list("apple", "banana", "cherry") # this is a list containing three distinct elements
anotherlist
class(anotherlist)


# check if an item exists in a list
"apple" %in% anotherlist
"apple" %in% thislist
"apple" %in% thislist[[1]]
```

```{r}
# matrices
thismatrix <- matrix(c("apple", "banana", "cherry", "orange", "grape", "pineapple", "pear", "melon", "fig"), nrow = 3, ncol = 3)

thismatrix

thismatrix[c(1, 2, 3), ] # select rows 1, 2, & 3

# use cbind to add additional elements to the matrix
newmatrix <- cbind(thismatrix, c("strawberry", "blueberry", "raspberry"))
newmatrix

# use rbind to add additional rows to the matrix
newermatrix <- rbind(newmatrix, c("1", "2", "3", "4"))
newermatrix

# remove rows & columns
thismatrix
thismatrix[c(-1), c(-1)] # you have removed row 1 and col 1

thismatrix[c(-1), ]
thismatrix

# check if an item exists
"apple" %in% thismatrix
"nonsense" %in% thismatrix

# check the dimensions of the matrix
dim(thismatrix)

dim(newermatrix)

# matrix length
length(thismatrix)
length(newermatrix)

# loop through a matrix
print(paste("thismatrix:",thismatrix))
cat("\n")
for (col in 1:ncol(thismatrix)) {
    for (row in 1:nrow(thismatrix)) {
        print(paste("Row:", row))
        print(paste0("col:", col))
        print(paste("value:",thismatrix[col, row]))
        cat("\n")
    }
}

thismatrix[1,2] # column 1; row 2

# combine two matrices
Matrix1 <- matrix(c("apple", "banana", "cherry", "grape"), nrow = 2, ncol = 2)
Matrix2 <- matrix(c("orange", "mango", "pineapple", "watermelon"), nrow = 2, ncol = 2)

Matrix1

Matrix2

# Adding it as rows
Matrix_Combined <- rbind(Matrix1, Matrix2)
Matrix_Combined

# Adding the matrices as columns
Matrix_Combined_cols <- cbind(Matrix1,Matrix2)
Matrix_Combined_cols
```

```{r}
# Plotting
plot(1,3)
```

```{r}
plot(c(1,8),c(3,10)) # draw two points at 1,3 & 8,10
```

```{r}
plot(1:10)
```
```{r}
# Drawing a line
plot(1:10, type="l")
```
```{r}
# Plot Labels
plot(1:10, main="My Graph", xlab="The x-axis", ylab="The y axis")
```

```{r}
# Graph Appearance

## Color
plot(1:10, col="red")

## Size
plot(1:10, cex=2)

# Point Shape
plot(1:10, pch=25, cex=2)
```

```{r}
# Line Graphs

plot(1:10, type="l")

```
```{r}
plot(1:10, type="l", col="blue")
```
```{r}
plot(1:10, type="l", lwd=2)
```

```{r}
# Line Styles

plot(1:10, type="l", lwd=5, lty=3)

# 0 removes the line
# 1 displays a solid line
# 2 displays a dashed line
# 3 displays a dotted line
# 4 displays a "dot dashed" line
# 5 displays a "long dashed" line
# 6 displays a "two dashed" line
```

```{r}
# Multiple Lines

line1 <- c(1,2,3,4,5,10)
line2 <- c(2,5,7,8,9,10)

plot(line1, type="l", col="blue")
lines(line2, type="l", col="red")
```

```{r}
# Scatter Plots
x <- c(5,7,8,7,2,2,9,4,11,12,9,6)
y <- c(99,86,87,88,111,103,87,94,78,77,85,86)

plot(x,y, main="Observation of Cars",xlab="Car age", ylab="Car speed") # Plot with labeling

```

```{r}
# Draw two plots on the same figure
# day one, the age and speed of 12 cars:
x1 <- c(5,7,8,7,2,2,9,4,11,12,9,6)
y1 <- c(99,86,87,88,111,103,87,94,78,77,85,86)

# day two, the age and speed of 15 cars:
x2 <- c(2,2,8,1,15,8,12,9,7,3,11,4,7,14,12)
y2 <- c(100,105,84,105,90,99,90,95,94,100,79,112,91,80,85)

plot(x1, y1, main="Observation of Cars", xlab="Car Age", ylab="Car Speed", col="red", cex=2)
points(x2,y2, col="blue", cex=2)

```

```{r}
# R Pie Charts

x <- c(seq(from=10, to=40, by=10))
pie(x) # This will draw a pie chart
# The pie chart will be created counterclockwise from the x-axis
```
```{r}
# Change the initial angle
pie(x, init.angle = 90)
```

```{r}
# Labels & Header
# Create a vector of pies
x <- c(10,20,30,40)

# Create a vector of labels
mylabel <- c("Apples", "Bananas", "Cherries", "Dates")

# Display the pie chart with labels
pie(x, label=mylabel, main="Fruits")
```

```{r}
# Colors
colors <- c("Red","Green", "Blue", "Yellow")

# Create a vector of pies
x <- c(10,20,30,40)

# Create a vector of labels
mylabel <- c("Apples", "Bananas", "Cherries", "Dates")

# Display the pie chart with colors
pie(x, mylabel, col=colors, main="Pie Chart")
```

```{r}
# Add a legend to your pie graph
# Colors
colors <- c("Red","Green", "Blue", "Yellow")

# Create a vector of pies
x <- c(10,20,30,40)

# Create a vector of labels
mylabel <- c("Apples", "Bananas", "Cherries", "Dates")

# Display the pie chart with colors
pie(x, mylabel, col=colors, main="Pie Chart")

# Adding the legend
legend("bottomright", mylabel, fill=colors)

# Locations for the legend
# bottomright, bottom, bottomleft, left, topleft, top, topright, right, center
```


```{r}
# Bar Charts

# x-axis values
x <- c("A", "B", "C", "D")

# y-axis values
y <- c(2,4,6,8)

barplot(y, names.arg = x)

```

```{r}
# Bar Color
 # x-axis values
x <- c("A", "B", "C", "D")

# y-axis values
y <- c(2,4,6,8)

barplot(y, names.arg = x, col="Red")
```

```{r}
# Bar Density / Texture

 # x-axis values
x <- c("A", "B", "C", "D")

# y-axis values
y <- c(2,4,6,8)

# Density
barplot(y, names.arg = x, col="Red", density=10)
```

```{r}
# Bar Width

 # x-axis values
x <- c("A", "B", "C", "D")

# y-axis values
y <- c(2,4,6,8)

# Density
barplot(y, names.arg = x, width=c(1,2,3,4))
```

```{r}
# Horizontal Bars

 # x-axis values
x <- c("A", "B", "C", "D")

# y-axis values
y <- c(2,4,6,8)

barplot(y, names.arg=x, horiz=TRUE)
```

```{r}
# STATISTICS
# Print the mtcars dataset (included by default)
mtcars
```

```{r}
# To get information about the dataset
?mtcars
```

```{r}
# Get dimensions of the dataset
dim(mtcars) # 32 observations & 11 variables
```
```{r}
# To install dplyr & tidyverse (optional)
install.packages("dplyr")
install.packages("tidyverse")
library(dplyr)
library(tidyverse)
# cheat-sheet: https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf
```
```{r}
glimpse(mtcars)
```

```{r}
# Get the function names of each row
Data_Cars <- mtcars
rownames(Data_Cars)
```

```{r}
# Printing Variable Values
Data_Cars$cyl
```

```{r}
Data_Cars <- mtcars
sort(Data_Cars$cyl)
```

```{r}
arrange(mtcars,  desc(disp), wt, cyl)
```

```{r}
# Analyzing the Data
Data_Cars  <- mtcars

summary(Data_Cars)
```

```{r}
# Max & Min
Data_Cars <- mtcars

which.max(Data_Cars$hp) # This will present the index of the row
which.min(Data_Cars$hp) # This will present the index of the row with the minimum value of hp

max(Data_Cars$hp) # This will present the maximum value
min(Data_Cars$hp) # This will present the minimum value

rownames(Data_Cars)[which.max(Data_Cars$hp)]
rownames(Data_Cars)[which.min(Data_Cars$hp)]
```

```{r}
# Mean, Median, & Mode

Data_Cars  <- mtcars

# Mean
mean(Data_Cars$wt)

# Median
median(Data_Cars$wt)

# Mode
names(sort(-table(Data_Cars$wt)))[1]
```

```{r}
-table(Data_Cars$wt) # This gives the value of -1 to each item in the data
table(Data_Cars$wt) # This give the value of 1 to each item in the data

sort(-table(Data_Cars$wt)) # This will sort from least to greatest, & count each time a duplicate is identified.
# The mode will be at the beginning of this array.

sort(table(Data_Cars$wt)) # This will sort from least to greatest, & count the number of times each duplicte is identified. 
# The mode will be at the end of this array.

# Find the Mode
names(sort(-table(Data_Cars$wt)))[1] # The table is tallied by negative values; The first number will be the most negative number (i.e. the counted the most times);

names(sort(desc(table(Data_Cars$wt))))[1] # This will sort the positive values of the table in a descending order such that the number with the greatest value is the first index in the array; 

tail(names(sort(table(Data_Cars$wt))), n=1) # Here the last index is address with tail since the table is sorted from least to greatest as shown below:

sort(table(Data_Cars$wt))

# names will grab the table name, which is the name of the data we are interested in.
```